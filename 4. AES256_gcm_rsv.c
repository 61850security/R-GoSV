#include <stdio.h>
#include <openssl/bio.h>
#include <openssl/evp.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/rand.h>
/* AES-GCM test data from NIST public test vectors */

/* Session layer fields */
char session_id = 0xA2; 
char length_id = 0x18;  
char common_header= 0x80;
char l_id = 0x16; 
char spdu_length1=0x00; 
char spdu_length2=0x00; 
char spdu_length3=0x00; 
char spdu_length4=0xA4;
char spdu_num1=0x00;    
char spdu_num2=0x00;
char spdu_num3=0x00;
char spdu_num4=0x0C;
char ver1=0x00;
char ver2=0x01;
char TimeofCurrentKey1=0x5B; 
char TimeofCurrentKey2=0xFC; 
char TimeofCurrentKey3=0xF6;
char TimeofCurrentKey4=0xB0;
char TimeofNextKey1=0x00;
char TimeofNextKey2=0x3C; 
char sa1=0x02; 
char sa2=0x03; 
char keyID1=0x00; 
char keyID2=0x00;
char keyID3=0x00;
char keyID4=0x0D;
char len1=0x00; 
char len2=0x00;
char len3=0x00;
char len4=0x6C;
char pl_type=0x82; 
char simulation=0x01; 
char APPID1=0x00;
char APPID2=0x01;
char length1=0x00; 
char length2=0x66;



/* Sample VAlue fields according to IEC 61850-9-2 */
char sav_PDU_tag=0x60;               /* sav_PDU tag  */
char sav_PDU_length=0x64; 	     /* sav_PDU length - size of APDU */
char noASDU_tag=0x80;		     /* number of ASDU tag  */ 
char noASDU_length=0x01;             /* number of ASDU length */
char noASDU=0x01;                    /* noASDU value  */
char SequenceofASDU_tag=0xA2;        /* SequenceofASDU tag   */
char SequenceofASDU_length=0x5F;     /* SequenceofASDU length - size of all ASDU  */
char ASDU_tag=0x30;                  /* ASDU tag */
char ASDU_length=0x5D;               /* ASDU length */
char svID_tag =0x80;                 /* Sample Value identifier tag   */
char svID_length =0x0C;              /* Sample Value identifier length */
char svID_1=0x46;                    /*  svID[12] naming   */
char svID_2=0x52;
char svID_3=0x45;
char svID_4=0x41;
char svID_5=0x2D;
char svID_6=0x47;
char svID_7=0x6F;
char svID_8=0x53;
char svID_9=0x56;
char svID_10=0x2D;  
char svID_11=0x31;
char svID_12=0x20;
char smpCnt_tag=0x82;                /* sample count tag */
char smpCnt_length =0x02;            /* sample count length */
char smpCnt_1=0x00;                  /* sample count */
char smpCnt_2=0x08;
char confRev_tag=0x83;               /* confRev tag - configuratin revision number */
char confRev_length=0x04;            /* confRev length */
char confRev1=0x00;                  /* confRev value */
char confRev2=0x00; 	     
char confRev3=0x00;
char confRev4=0x01;                   
char smpSynch_tag = 0x85;            /* smpSynch tag -synchronization identifier */
char smpSynch_length =0x01;          /* smpSynch_length */
char smpSynch =0x00; 		     /* smpSynch value  */
char SequenceofData_tag =0x87;       /* SequenceofData tag */
char SequenceofData_length=0x40;     /* SequenceofData length */

/* Enter your custom measurement values in hexa decimal    */
char a[64]=     { 0x00, 0x00, 0x00, 0x5A, 0x12, 0x15, 0x12, 0x64,
                  0x11, 0x12, 0x18, 0x22, 0x14, 0x12, 0x17, 0x16, 
		  0x30, 0x42, 0x10, 0x14, 0x12, 0x15, 0x12, 0x64,
                  0x11, 0x12, 0x18, 0x22, 0x14, 0x12, 0x17, 0x16, 
		  0x30, 0x42, 0x10, 0x14, 0x12, 0x15, 0x12, 0x64,
                  0x11, 0x12, 0x18, 0x22, 0x14, 0x12, 0x17, 0x16, 
		  0x30, 0x42, 0x10, 0x14, 0x12, 0x15, 0x12, 0x64,
                  0x11, 0x12, 0x18, 0x22, 0x14, 0x12, 0x17, 0x16 };

static const unsigned char gcm_key[] = {
    0xee, 0xbc, 0x1f, 0x57, 0x48, 0x7f, 0x51, 0x92, 0x1c, 0x04, 0x65, 0x66,
    0x5f, 0x8a, 0xe6, 0xd1, 0x65, 0x8b, 0xb2, 0x6d, 0xe6, 0xf8, 0xa0, 0x69,
    0xa3, 0x52, 0x02, 0x93, 0xa5, 0x72, 0x07, 0x8f
};

static const unsigned char gcm_iv[] = {
    0x99, 0xaa, 0x3e, 0x68, 0xed, 0x81, 0x73, 0xa0, 0xee, 0xd0, 0x66, 0x84
};

static const unsigned char gcm_pt[] = 
{
					0xA2, 0x18, 0x80, 0x16, 0x00, 0x00, 0x00, 0xA4, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x01, 0x5B, 
					0xFC, 0xF6, 0xB0, 0x00, 0x3C, 0x02, 0x03, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x6C,
					0x82, 0x01, 0x00, 0x01, 0x00, 0x66, 0x60, 0x64, 0x80, 0x01, 0x01, 0xA2, 0x5F, 0x30, 0x5D,
					0x80, 0x0C, 0x46, 0x52, 0x45, 0x41, 0x2D, 0x47, 0x6F, 0x53, 0x56, 0x2D, 0x31, 0x20, 0x82,
					0x02, 0x00, 0x08, 0x83, 0x04, 0x00, 0x00, 0x00, 0x01, 0x85, 0x01, 0x00, 0x87, 0x40, 0x00, 
					0x00, 0x00, 0x5A, 0x12, 0x15, 0x12, 0x64, 0x11, 0x12, 0x18, 0x22, 0x14, 0x12, 0x17, 0x16,
                                        0x30, 0x42, 0x10, 0x14, 0x12, 0x15, 0x12, 0x64, 0x11, 0x12, 0x18, 0x22, 0x14, 0x12, 0x17, 
                                        0x16, 0x30, 0x42, 0x10, 0x14, 0x12, 0x15, 0x12, 0x64, 0x11, 0x12, 0x18, 0x22, 0x14, 0x12,
                                        0x17, 0x16, 0x30, 0x42, 0x10, 0x14, 0x12, 0x15, 0x12, 0x64, 0x11, 0x12, 0x18, 0x22, 0x14,
                                        0x12, 0x17, 0x16
};

static const unsigned char gcm_aad[] = {
    0x4d, 0x23, 0xc3, 0xce, 0xc3, 0x34, 0xb4, 0x9b, 0xdb, 0x37, 0x0c, 0x43, 0x7f, 0xec, 0x78, 0xde
};

static const unsigned char gcm_ct[] = 
{
		0xa0, 0x50, 0x43, 0x00, 0xf3, 0x8f, 0x23, 0xd6, 0x3e, 0x07, 0x34, 0x98, 0x75, 0xd8, 0xbe, 0x6f,
		0x7c, 0x66, 0x48, 0x6c, 0xa9, 0xe0, 0x7e, 0x8e, 0x7f, 0x3e, 0x16, 0x02, 0x31, 0x9c, 0x2b, 0x4e,
		0xdc, 0x48, 0xff, 0xc9, 0x98, 0x30, 0x2e, 0x26, 0x39, 0xb0, 0x03, 0x7f, 0x05, 0x3e, 0xef, 0x9e,
		0x57, 0x41, 0xc1, 0xd5, 0x0f, 0x7c, 0x9d, 0xe7, 0xcc, 0x31, 0xab, 0xb8, 0x05, 0xcc, 0xe4, 0x6e,
		0xfd, 0x4c, 0xc8, 0x9d, 0x25, 0x8e, 0x98, 0xf8, 0x2e, 0xaf, 0xcb, 0xa0, 0x0a, 0x16, 0x94, 0x1f,
		0x2a, 0xed, 0x6e, 0x34, 0x57, 0x77, 0x1f, 0x7a, 0xc1, 0x24, 0xaa, 0x1c, 0x6f, 0x27, 0x41, 0xec,
		0xd8, 0x6c, 0x3a, 0xfa, 0x2a, 0x95, 0xea, 0x7c, 0x50, 0xcf, 0x66, 0xa1, 0x74, 0xa4, 0x75, 0xef,
		0xb2, 0xdf, 0x9c, 0x51, 0x00, 0x4e, 0x94, 0xe2, 0x19, 0x33, 0x7f, 0x15, 0xcb, 0xd3, 0xda, 0x29,
		0x48, 0x42, 0xe5, 0x4d, 0x88, 0xea, 0x82, 0x1a, 0x88, 0x27    
                         
};

static const unsigned char gcm_tag[] = 
{
	0xd0, 0xa1, 0xb4, 0x58, 0xf2, 0x08, 0x29, 0x42, 0x2a, 0x4e, 0xba, 0xa5, 0x1c, 0xd9, 0x10				
};

void aes_gcm_encrypt(void)
{
    EVP_CIPHER_CTX *ctx;
    int outlen, tmplen;
    unsigned char outbuf[1024];
    printf("AES GCM Encrypt:\n");
    printf("Plaintext:\n");
    BIO_dump_fp(stdout, gcm_pt, sizeof(gcm_pt));
    ctx = EVP_CIPHER_CTX_new();
    /* Set cipher type and mode */
    EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL);
    /* Set IV length if default 96 bits is not appropriate */
    EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, sizeof(gcm_iv), NULL);
    /* Initialise key and IV */
    EVP_EncryptInit_ex(ctx, NULL, NULL, gcm_key, gcm_iv);
    /* Zero or more calls to specify any AAD */
    EVP_EncryptUpdate(ctx, NULL, &outlen, gcm_aad, sizeof(gcm_aad));
    /* Encrypt plaintext */
    EVP_EncryptUpdate(ctx, outbuf, &outlen, gcm_pt, sizeof(gcm_pt));
    /* Output encrypted block */
    printf("Ciphertext:\n");
    BIO_dump_fp(stdout, outbuf, outlen);
    /* Finalise: note get no output for GCM */
    EVP_EncryptFinal_ex(ctx, outbuf, &outlen);
    /* Get tag */
    EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, 16, outbuf);
    /* Output tag */
    printf("Tag:\n");
    BIO_dump_fp(stdout, outbuf, 16);
    EVP_CIPHER_CTX_free(ctx);
}

void aes_gcm_decrypt(void)
{
    EVP_CIPHER_CTX *ctx;
    int outlen, tmplen, rv;
    unsigned char outbuf[1024];
    printf("AES GCM Derypt:\n");
    printf("Ciphertext:\n");
    BIO_dump_fp(stdout, gcm_ct, sizeof(gcm_ct));
    ctx = EVP_CIPHER_CTX_new();
    /* Select cipher */
    EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL);
    /* Set IV length, omit for 96 bits */
    EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, sizeof(gcm_iv), NULL);
    /* Specify key and IV */
    EVP_DecryptInit_ex(ctx, NULL, NULL, gcm_key, gcm_iv);
    /* Zero or more calls to specify any AAD */
    EVP_DecryptUpdate(ctx, NULL, &outlen, gcm_aad, sizeof(gcm_aad));
    /* Decrypt plaintext */
    EVP_DecryptUpdate(ctx, outbuf, &outlen, gcm_ct, sizeof(gcm_ct));
    /* Output decrypted block */
    printf("Plaintext:\n");
    BIO_dump_fp(stdout, outbuf, outlen);
    /* Set expected tag value. */
    EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, sizeof(gcm_tag),
                        (void *)gcm_tag);
    /* Finalise: note get no output for GCM */
    rv = EVP_DecryptFinal_ex(ctx, outbuf, &outlen);
    /*
     * Print out return value. If this is not successful authentication
     * failed and plaintext is not trustworthy.
     */
    printf("Tag Verify %s\n", rv > 0 ? "Successful!" : "Failed!");
    EVP_CIPHER_CTX_free(ctx);
}

int main(int argc, char **argv)
{
    aes_gcm_encrypt();
    aes_gcm_decrypt();
   
    return 0;		
}
